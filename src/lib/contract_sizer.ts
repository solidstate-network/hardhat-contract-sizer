import pkg from '../../package.json';
import type { HardhatContractSizerConfig } from '../types.js';
import { DEPLOYED_SIZE_LIMIT, INIT_SIZE_LIMIT, UNITS } from './constants.js';
import chalk from 'chalk';
import Table from 'cli-table3';
import fs from 'fs';
import { HardhatPluginError } from 'hardhat/plugins';
import type { HookContext } from 'hardhat/types/hooks';
import path from 'path';
import stripAnsi from 'strip-ansi';

const formatSize = (
  unit: HardhatContractSizerConfig['unit'],
  size: number,
  limit?: number,
) => {
  const divisor = UNITS[unit];
  const decimalString = (size / divisor).toFixed(3);

  if (limit) {
    if (size > limit) {
      return chalk.red.bold(decimalString);
    } else if (size > limit * 0.9) {
      return chalk.yellow.bold(decimalString);
    }
  }

  return decimalString;
};

const formatSizeDiff = (
  unit: HardhatContractSizerConfig['unit'],
  size: number,
  previousSize?: number,
) => {
  if (!previousSize) {
    return '';
  } else if (size < previousSize) {
    return chalk.green(`-${formatSize(unit, previousSize - size)}`);
  } else if (size > previousSize) {
    return chalk.red(`+${formatSize(unit, size - previousSize)}`);
  } else {
    return chalk.gray(formatSize(unit, 0));
  }
};

export const sizeContracts = async (
  context: HookContext,
  config: HardhatContractSizerConfig,
) => {
  type SolcSettings = {
    solcVersion: string;
    optimizer: boolean;
    runs: number;
  };

  type OutputItem = {
    sourceName: string;
    displayName: string;
    deploySize: number;
    previousDeploySize?: number;
    initSize: number;
    previousInitSize?: number;
    solcSettings: SolcSettings;
  };

  const DEFAULT_SOLC_SETTINGS: SolcSettings = {
    solcVersion: 'unknown',
    optimizer: false,
    runs: 0,
  };

  const outputPath = path.resolve(
    context.config.paths.cache,
    '.hardhat_contract_sizer_output.json',
  );

  // read results of previous runs from disk

  const previousSizes: { [sourceName: string]: number } = {};
  const previousInitSizes: { [sourceName: string]: number } = {};

  if (fs.existsSync(outputPath)) {
    const previousOutput: {
      sourceName: string;
      deploySize: number;
      initSize: number;
    }[] = JSON.parse((await fs.promises.readFile(outputPath)).toString());

    previousOutput.forEach((el) => {
      previousSizes[el.sourceName] = el.deploySize;
      previousInitSizes[el.sourceName] = el.initSize;
    });
  }

  // get list of all contracts and filter according to configuraiton

  const fullNames = Array.from(
    await context.artifacts.getAllFullyQualifiedNames(),
  ).filter((fullName) => {
    if (config.only.length && !config.only.some((m) => fullName.match(m)))
      return false;
    if (config.except.length && config.except.some((m) => fullName.match(m)))
      return false;
    return true;
  });

  // get contract artifacts

  const artifacts = await Promise.all(
    fullNames.map((fullName) => context.artifacts.readArtifact(fullName)),
  );

  // get the solc settings used for each artifact, indexed by build info id

  const buildInfoSolcSettings: {
    [buildInfoId: string]: SolcSettings;
  } = {};

  await Promise.all(
    artifacts.map(async ({ buildInfoId }) => {
      // contracts not generated by Hardhat do not have a build info id
      if (buildInfoId) {
        const buildInfoPath =
          await context.artifacts.getBuildInfoPath(buildInfoId);

        // TODO: buildInfoPath is never undefined
        const content = await fs.promises.readFile(buildInfoPath!, 'utf-8');
        const json = JSON.parse(content);

        buildInfoSolcSettings[buildInfoId] = {
          solcVersion: json.solcVersion ?? DEFAULT_SOLC_SETTINGS.solcVersion,
          optimizer:
            json.input?.settings?.optimizer?.enabled ??
            DEFAULT_SOLC_SETTINGS.optimizer,
          runs:
            json.input?.settings?.optimizer?.runs ?? DEFAULT_SOLC_SETTINGS.runs,
        };
      }
    }),
  );

  // calculate contract sizes

  const outputData: OutputItem[] = artifacts.map((artifact) => {
    const {
      sourceName,
      contractName,
      deployedBytecode,
      bytecode,
      buildInfoId,
    } = artifact;

    const deploySize = Buffer.from(
      deployedBytecode.replace(/__\$\w*\$__/g, '0'.repeat(40)).slice(2),
      'hex',
    ).length;
    const initSize = Buffer.from(
      bytecode.replace(/__\$\w*\$__/g, '0'.repeat(40)).slice(2),
      'hex',
    ).length;

    const fullName = `${sourceName}:${contractName}`;

    // contracts not generated by Hardhat do not have a build info id, so fallback to default solc settings
    const solcSettings =
      buildInfoSolcSettings[buildInfoId!] ?? DEFAULT_SOLC_SETTINGS;

    return {
      sourceName,
      displayName: config.flat ? fullName.split('/').pop()! : fullName,
      deploySize,
      initSize,
      solcSettings,
    };
  });

  // match with data from previous runs

  for (const outputItem of outputData) {
    outputItem.previousDeploySize = previousSizes[outputItem.sourceName];
    outputItem.previousInitSize = previousInitSizes[outputItem.sourceName];
  }

  // check for display name clashes among contracts

  outputData.reduce((acc, { displayName }) => {
    if (acc.has(displayName)) {
      throw new HardhatPluginError(
        pkg.name,
        `ambiguous contract name: ${displayName}`,
      );
    }

    acc.add(displayName);
    return acc;
  }, new Set());

  // write size results to disk for future comparison

  await fs.promises.writeFile(outputPath, JSON.stringify(outputData));

  // sort results

  if (config.alphaSort) {
    outputData.sort((a, b) =>
      a.displayName.toUpperCase() > b.displayName.toUpperCase() ? 1 : -1,
    );
  } else {
    outputData.sort((a, b) => a.deploySize - b.deploySize);
  }

  // group results by solc settings

  const outputDataBySolcSettings: { [solcVersion: string]: OutputItem[] } =
    outputData.reduce(
      (acc, el) => {
        const key = JSON.stringify(el.solcSettings);
        acc[key] ??= [];
        acc[key].push(el);
        return acc;
      },
      {} as { [solcVersion: string]: OutputItem[] },
    );

  // generate table of results

  const table = new Table({
    style: { head: [], border: [], 'padding-left': 2, 'padding-right': 2 },
    chars: {
      mid: '·',
      'top-mid': '|',
      'left-mid': ' ·',
      'mid-mid': '|',
      'right-mid': '·',
      left: ' |',
      'top-left': ' ·',
      'top-right': '·',
      'bottom-left': ' ·',
      'bottom-right': '·',
      middle: '·',
      top: '-',
      bottom: '-',
      'bottom-mid': '|',
    },
  });

  table.push([
    {
      content: chalk.bold('Contract Name'),
    },
    {
      content: chalk.bold(`Deployed size (${config.unit}) (change)`),
    },
    {
      content: chalk.bold(`Initcode size (${config.unit}) (change)`),
    },
  ]);

  for (const key in outputDataBySolcSettings) {
    const outputData = outputDataBySolcSettings[key];

    const solcSettings: SolcSettings = JSON.parse(key) as SolcSettings;

    const { solcVersion } = solcSettings;
    const optimizer =
      solcVersion === 'unknown' ? 'unknown' : solcSettings.optimizer;
    const runs = solcVersion === 'unknown' ? 'unknown' : solcSettings.runs;

    table.push([
      {
        content: chalk.gray(`Solc version: ${solcVersion}`),
      },
      {
        content: chalk.gray(`Optimizer enabled: ${optimizer}`),
      },
      {
        content: chalk.gray(`Runs: ${runs}`),
      },
    ]);

    for (let item of outputData) {
      if (item.deploySize === 0 && item.initSize === 0) {
        continue;
      }

      const deploySize = formatSize(
        config.unit,
        item.deploySize,
        DEPLOYED_SIZE_LIMIT,
      );
      const initSize = formatSize(config.unit, item.initSize, INIT_SIZE_LIMIT);

      const deployDiff = formatSizeDiff(
        config.unit,
        item.deploySize,
        item.previousDeploySize,
      );
      const initDiff = formatSizeDiff(
        config.unit,
        item.initSize,
        item.previousInitSize,
      );

      table.push([
        { content: item.displayName },
        { content: `${deploySize} (${deployDiff})`, hAlign: 'right' },
        { content: `${initSize} (${initDiff})`, hAlign: 'right' },
      ]);
    }
  }

  // print table or write to disk, according to configuration

  if (config.outputFile) {
    fs.writeFileSync(config.outputFile, `${stripAnsi(table.toString())}\n`);
  } else {
    console.log(table.toString());
  }

  // count oversized contracts

  const oversizedCount = outputData.reduce((acc, el) => {
    if (el.deploySize > DEPLOYED_SIZE_LIMIT || el.initSize > INIT_SIZE_LIMIT) {
      acc++;
    }
    return acc;
  }, 0);

  // print or throw size errors, according to configuration

  if (oversizedCount > 0) {
    const subjectPredicateFragment =
      oversizedCount === 1 ? 'contract exceeds' : 'contracts exceed';

    const deployedSizeLimitFragment = `${formatSize(config.unit, DEPLOYED_SIZE_LIMIT)} ${config.unit}`;
    const initSizeLimitFragment = `${formatSize(config.unit, INIT_SIZE_LIMIT)} ${config.unit}`;

    const message = `Warning: ${oversizedCount} ${subjectPredicateFragment} the size limit for mainnet deployment (${deployedSizeLimitFragment} deployed, ${initSizeLimitFragment} init).`;

    if (config.strict) {
      throw new HardhatPluginError(pkg.name, message);
    } else if (!config.outputFile) {
      console.log();
      console.log(chalk.red(message));
    }
  }
};
