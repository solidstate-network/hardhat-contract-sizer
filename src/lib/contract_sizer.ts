import pkg from '../../package.json';
import type {
  ContractSizerConfig,
  MergedOutputItem,
  OutputItem,
  SolcSettings,
} from '../types.js';
import { DEPLOYED_SIZE_LIMIT, INIT_SIZE_LIMIT } from './constants.js';
import { HardhatPluginError } from 'hardhat/plugins';
import type { HookContext } from 'hardhat/types/hooks';
import type { HardhatRuntimeEnvironment } from 'hardhat/types/hre';
import child_process from 'node:child_process';
import fs from 'node:fs';
import os from 'node:os';
import path from 'node:path';
import { simpleGit } from 'simple-git';

const getTmpHreAtGitRef = async (
  hre: Pick<HardhatRuntimeEnvironment, 'config'>,
  ref: string,
): Promise<HardhatRuntimeEnvironment> => {
  const git = simpleGit(hre.config.paths.root);
  ref = await git.revparse(ref);

  const tmpdir = path.resolve(os.tmpdir(), pkg.name, ref);
  const successfulSetupIndicatorFile = path.resolve(
    tmpdir,
    '.setup_successful',
  );

  if (!fs.existsSync(successfulSetupIndicatorFile)) {
    // delete the directory in case a previous setup failed
    await fs.promises.rm(tmpdir, { recursive: true, force: true });
    await fs.promises.mkdir(tmpdir, { recursive: true });

    try {
      await git.cwd(tmpdir);
      await git.init();
      await git.addRemote('origin', hre.config.paths.root);
      await git.fetch('origin', ref, { '--depth': 1 });
      await git.checkout(ref);

      child_process.spawnSync('npm', ['install'], {
        cwd: tmpdir,
        stdio: 'inherit',
      });

      await fs.promises.writeFile(successfulSetupIndicatorFile, '');
    } catch (error) {
      await fs.promises.rm(tmpdir, { recursive: true, force: true });
      throw new HardhatPluginError(pkg.name, error as string);
    }
  }

  // TODO: fallback to local createHardhatRuntimeEnvironment function
  const { createHardhatRuntimeEnvironment } = await import(
    path.resolve(tmpdir, 'node_modules/hardhat/dist/src/hre')
  );

  const { findClosestHardhatConfig } = await import(
    path.resolve(
      tmpdir,
      'node_modules/hardhat/dist/src/internal/config-loading',
    )
  );

  const tmpConfigPath = await findClosestHardhatConfig(tmpdir);
  const tmpConfig = await import(tmpConfigPath);

  return await createHardhatRuntimeEnvironment(
    tmpConfig.default,
    { config: tmpConfigPath },
    tmpdir,
  );
};

const getArtifacts = async (
  context: HookContext,
  config: ContractSizerConfig,
) => {
  // get list of all contracts and filter according to configuraiton

  const fullNames = Array.from(
    await context.artifacts.getAllFullyQualifiedNames(),
  ).filter((fullName) => {
    if (config.only.length && !config.only.some((m) => fullName.match(m)))
      return false;
    if (config.except.length && config.except.some((m) => fullName.match(m)))
      return false;
    return true;
  });

  // get contract artifacts

  const artifacts = await Promise.all(
    fullNames.map((fullName) => context.artifacts.readArtifact(fullName)),
  );

  return artifacts;
};

export const loadContractSizes = async (
  context: HookContext,
  config: ContractSizerConfig,
  ref?: string,
): Promise<OutputItem[]> => {
  if (ref) {
    const tmpHre = await getTmpHreAtGitRef(context, ref);

    await tmpHre.tasks.getTask('compile').run();

    context = tmpHre;
  }

  return await loadContractSizesFromArtifacts(context, config);
};

const loadContractSizesFromArtifacts = async (
  context: HookContext,
  config: ContractSizerConfig,
): Promise<OutputItem[]> => {
  const DEFAULT_SOLC_SETTINGS: SolcSettings = {
    solcVersion: 'unknown',
    optimizer: false,
    runs: 0,
  };

  const artifacts = await getArtifacts(context, config);

  // get the solc settings used for each artifact, indexed by build info id

  const buildInfoSolcSettings: {
    [buildInfoId: string]: SolcSettings;
  } = {};

  await Promise.all(
    artifacts.map(async ({ buildInfoId }) => {
      // contracts not generated by Hardhat do not have a build info id
      if (buildInfoId) {
        const buildInfoPath =
          await context.artifacts.getBuildInfoPath(buildInfoId);

        // TODO: buildInfoPath is never undefined
        const content = await fs.promises.readFile(buildInfoPath!, 'utf-8');
        const json = JSON.parse(content);

        buildInfoSolcSettings[buildInfoId] = {
          solcVersion: json.solcVersion ?? DEFAULT_SOLC_SETTINGS.solcVersion,
          optimizer:
            json.input?.settings?.optimizer?.enabled ??
            DEFAULT_SOLC_SETTINGS.optimizer,
          runs:
            json.input?.settings?.optimizer?.runs ?? DEFAULT_SOLC_SETTINGS.runs,
        };
      }
    }),
  );

  // calculate contract sizes

  const outputData: OutputItem[] = artifacts.map((artifact) => {
    const {
      sourceName,
      contractName,
      deployedBytecode,
      bytecode,
      buildInfoId,
    } = artifact;

    const deploySize = Buffer.from(
      deployedBytecode.replace(/__\$\w*\$__/g, '0'.repeat(40)).slice(2),
      'hex',
    ).length;
    const initSize = Buffer.from(
      bytecode.replace(/__\$\w*\$__/g, '0'.repeat(40)).slice(2),
      'hex',
    ).length;

    // contracts not generated by Hardhat do not have a build info id, so fallback to default solc settings
    const solcSettings =
      buildInfoSolcSettings[buildInfoId!] ?? DEFAULT_SOLC_SETTINGS;

    return {
      sourceName,
      contractName,
      deploySize,
      initSize,
      solcSettings,
    };
  });

  return outputData;
};

export const mergeContractSizes = (
  contractSizesA: OutputItem[],
  contractSizesB: OutputItem[],
): MergedOutputItem[] => {
  // contractSizesB represents the updated revision
  // contractSizesA represents the previous revision

  const contractSizesAByName = contractSizesA.reduce(
    (acc, el) => {
      const name = `${el.sourceName}:${el.contractName}`;
      acc[name] = el;
      return acc;
    },
    {} as { [name: string]: OutputItem },
  );

  const contractSizesBByName = contractSizesB.reduce(
    (acc, el) => {
      const name = `${el.sourceName}:${el.contractName}`;
      acc[name] = el;
      return acc;
    },
    {} as { [name: string]: OutputItem },
  );

  const mergedContractSizesByName: { [name: string]: MergedOutputItem } = {};

  for (const name in contractSizesBByName) {
    const itemA = contractSizesAByName[name] ?? { deploySize: 0, initSize: 0 };
    const itemB = contractSizesBByName[name];

    mergedContractSizesByName[name] = {
      ...itemB,
      previousDeploySize: itemA.deploySize,
      previousInitSize: itemA.initSize,
    };
  }

  for (const name in contractSizesAByName) {
    const item = mergedContractSizesByName[name];

    if (!item) {
      const itemA = contractSizesAByName[name];

      // TODO: solc settings are not applicable because contract does not exist in current revision

      mergedContractSizesByName[name] = {
        sourceName: itemA.sourceName,
        contractName: itemA.contractName,
        deploySize: 0,
        initSize: 0,
        previousDeploySize: itemA.deploySize,
        previousInitSize: itemA.initSize,
        solcSettings: itemA.solcSettings,
      };
    }
  }

  return Object.values(mergedContractSizesByName);
};

export const countOversizedContracts = (sizedContracts: OutputItem[]) => {
  return sizedContracts.reduce((acc, el) => {
    if (el.deploySize > DEPLOYED_SIZE_LIMIT || el.initSize > INIT_SIZE_LIMIT) {
      acc++;
    }
    return acc;
  }, 0);
};
