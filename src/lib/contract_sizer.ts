import pkg from '../../package.json';
import type {
  HardhatContractSizerConfig,
  OutputItem,
  SolcSettings,
} from '../types.js';
import { DEPLOYED_SIZE_LIMIT, INIT_SIZE_LIMIT } from './constants.js';
import { printContractSizes } from './print.js';
import chalk from 'chalk';
import fs from 'fs';
import { HardhatPluginError } from 'hardhat/plugins';
import type { HookContext } from 'hardhat/types/hooks';

const getArtifacts = async (
  context: HookContext,
  config: HardhatContractSizerConfig,
) => {
  // get list of all contracts and filter according to configuraiton

  const fullNames = Array.from(
    await context.artifacts.getAllFullyQualifiedNames(),
  ).filter((fullName) => {
    if (config.only.length && !config.only.some((m) => fullName.match(m)))
      return false;
    if (config.except.length && config.except.some((m) => fullName.match(m)))
      return false;
    return true;
  });

  // get contract artifacts

  const artifacts = await Promise.all(
    fullNames.map((fullName) => context.artifacts.readArtifact(fullName)),
  );

  return artifacts;
};

export const sizeContracts = async (
  context: HookContext,
  config: HardhatContractSizerConfig,
) => {
  const DEFAULT_SOLC_SETTINGS: SolcSettings = {
    solcVersion: 'unknown',
    optimizer: false,
    runs: 0,
  };

  const artifacts = await getArtifacts(context, config);

  // get the solc settings used for each artifact, indexed by build info id

  const buildInfoSolcSettings: {
    [buildInfoId: string]: SolcSettings;
  } = {};

  await Promise.all(
    artifacts.map(async ({ buildInfoId }) => {
      // contracts not generated by Hardhat do not have a build info id
      if (buildInfoId) {
        const buildInfoPath =
          await context.artifacts.getBuildInfoPath(buildInfoId);

        // TODO: buildInfoPath is never undefined
        const content = await fs.promises.readFile(buildInfoPath!, 'utf-8');
        const json = JSON.parse(content);

        buildInfoSolcSettings[buildInfoId] = {
          solcVersion: json.solcVersion ?? DEFAULT_SOLC_SETTINGS.solcVersion,
          optimizer:
            json.input?.settings?.optimizer?.enabled ??
            DEFAULT_SOLC_SETTINGS.optimizer,
          runs:
            json.input?.settings?.optimizer?.runs ?? DEFAULT_SOLC_SETTINGS.runs,
        };
      }
    }),
  );

  // calculate contract sizes

  const outputData: OutputItem[] = artifacts.map((artifact) => {
    const {
      sourceName,
      contractName,
      deployedBytecode,
      bytecode,
      buildInfoId,
    } = artifact;

    const deploySize = Buffer.from(
      deployedBytecode.replace(/__\$\w*\$__/g, '0'.repeat(40)).slice(2),
      'hex',
    ).length;
    const initSize = Buffer.from(
      bytecode.replace(/__\$\w*\$__/g, '0'.repeat(40)).slice(2),
      'hex',
    ).length;

    const fullName = `${sourceName}:${contractName}`;

    // contracts not generated by Hardhat do not have a build info id, so fallback to default solc settings
    const solcSettings =
      buildInfoSolcSettings[buildInfoId!] ?? DEFAULT_SOLC_SETTINGS;

    return {
      sourceName,
      contractName,
      displayName: config.flat ? fullName.split('/').pop()! : fullName,
      deploySize,
      initSize,
      solcSettings,
    };
  });

  // count oversized contracts

  const oversizedCount = outputData.reduce((acc, el) => {
    if (el.deploySize > DEPLOYED_SIZE_LIMIT || el.initSize > INIT_SIZE_LIMIT) {
      acc++;
    }
    return acc;
  }, 0);

  // check for display name clashes among contracts

  outputData.reduce((acc, { displayName }) => {
    if (acc.has(displayName)) {
      throw new HardhatPluginError(
        pkg.name,
        `ambiguous contract name: ${displayName}`,
      );
    }

    acc.add(displayName);
    return acc;
  }, new Set());

  // sort results

  if (config.alphaSort) {
    outputData.sort((a, b) =>
      a.displayName.toUpperCase() > b.displayName.toUpperCase() ? 1 : -1,
    );
  } else {
    outputData.sort((a, b) => a.deploySize - b.deploySize);
  }

  const outputDataBySolcSettings = groupOutputDataBySolcSettings(outputData);

  printContractSizes(outputDataBySolcSettings, config, oversizedCount);
};

const groupOutputDataBySolcSettings = (
  outputData: OutputItem[],
): { [solcVersion: string]: OutputItem[] } => {
  return outputData.reduce(
    (acc, el) => {
      const key = JSON.stringify(el.solcSettings);
      acc[key] ??= [];
      acc[key].push(el);
      return acc;
    },
    {} as { [solcVersion: string]: OutputItem[] },
  );
};
