import pkg from '../../package.json' with { type: 'json' };
import type {
  ContractSizerConfig,
  MergedContractSize,
  ContractSize,
  SolcSettings,
} from '../types.js';
import { DEPLOYED_SIZE_LIMIT, INIT_SIZE_LIMIT } from './constants.js';
import { DEFAULT_SOLC_SETTINGS, equal } from './solc_settings.js';
import { readJsonFile } from '@nomicfoundation/hardhat-utils/fs';
import { readArtifacts } from '@solidstate/hardhat-solidstate-utils/filter';
import { HardhatPluginError } from 'hardhat/plugins';
import type { HookContext } from 'hardhat/types/hooks';

export const loadContractSizes = async (
  context: HookContext,
  config: ContractSizerConfig,
): Promise<ContractSize[]> => {
  return await loadContractSizesFromArtifacts(context, config);
};

const loadContractSizesFromArtifacts = async (
  context: HookContext,
  config: ContractSizerConfig,
): Promise<ContractSize[]> => {
  // get the solc settings used for each artifact, indexed by build info id

  const buildInfoSolcSettings: {
    [buildInfoId: string]: SolcSettings;
  } = {};

  const buildInfoIds = Array.from(await context.artifacts.getAllBuildInfoIds());

  await Promise.all(
    buildInfoIds.map(async (buildInfoId) => {
      const buildInfoPath =
        await context.artifacts.getBuildInfoPath(buildInfoId);

      const buildInfo = (await readJsonFile(buildInfoPath!)) as any;

      buildInfoSolcSettings[buildInfoId] = {
        solcVersion: buildInfo.solcVersion ?? DEFAULT_SOLC_SETTINGS.solcVersion,
        optimizer:
          buildInfo.input?.settings?.optimizer?.enabled ??
          DEFAULT_SOLC_SETTINGS.optimizer,
        runs:
          buildInfo.input?.settings?.optimizer?.runs ??
          DEFAULT_SOLC_SETTINGS.runs,
      };
    }),
  );

  // get contract artifacts, filtered according to configuration

  const artifacts = await readArtifacts(context, config);

  // calculate contract sizes

  const outputData: ContractSize[] = artifacts.map((artifact) => {
    const {
      sourceName,
      contractName,
      deployedBytecode,
      bytecode,
      buildInfoId,
    } = artifact;

    const deploySize = Buffer.from(
      deployedBytecode.replace(/__\$\w*\$__/g, '0'.repeat(40)).slice(2),
      'hex',
    ).length;
    const initSize = Buffer.from(
      bytecode.replace(/__\$\w*\$__/g, '0'.repeat(40)).slice(2),
      'hex',
    ).length;

    // contracts not generated by Hardhat do not have a build info id, so fallback to default solc settings
    const solcSettings =
      buildInfoSolcSettings[buildInfoId!] ?? DEFAULT_SOLC_SETTINGS;

    return {
      sourceName,
      contractName,
      deploySize,
      initSize,
      solcSettings,
    };
  });

  return outputData;
};

export const mergeContractSizes = (
  contractSizesA: ContractSize[],
  contractSizesB: ContractSize[],
): MergedContractSize[] => {
  // index contract size data by fully qualified contract name
  // contractSizesB represents the updated revision
  // contractSizesA represents the previous revision

  const contractSizesAByName = contractSizesA.reduce(
    (acc, el) => {
      const name = `${el.sourceName}:${el.contractName}`;
      acc[name] = el;
      return acc;
    },
    {} as { [name: string]: ContractSize },
  );

  const contractSizesBByName = contractSizesB.reduce(
    (acc, el) => {
      const name = `${el.sourceName}:${el.contractName}`;
      acc[name] = el;
      return acc;
    },
    {} as { [name: string]: ContractSize },
  );

  // group contract names by whether contract exists in revision A, B, or both

  const contractNamesA = new Set(Object.keys(contractSizesAByName));
  const contractNamesB = new Set(Object.keys(contractSizesBByName));

  const keptContractNames = contractNamesA.intersection(contractNamesB);
  const removedContractNames = contractNamesA.difference(keptContractNames);
  const addedContractNames = contractNamesB.difference(keptContractNames);

  // merge the contract size data

  const mergedContractSizes: MergedContractSize[] = [];

  keptContractNames.forEach((name) => {
    const itemA = contractSizesAByName[name];
    const itemB = contractSizesBByName[name];

    mergedContractSizes.push({
      ...itemB,
      previousDeploySize: itemA.deploySize,
      previousInitSize: itemA.initSize,
      solcSettingsChanged: !equal(itemA.solcSettings, itemB.solcSettings),
    });
  });

  addedContractNames.forEach((name) => {
    const itemB = contractSizesBByName[name];

    mergedContractSizes.push({
      ...itemB,
      previousDeploySize: 0,
      previousInitSize: 0,
      solcSettingsChanged: true,
    });
  });

  removedContractNames.forEach((name) => {
    const itemA = contractSizesAByName[name];

    mergedContractSizes.push({
      sourceName: itemA.sourceName,
      contractName: itemA.contractName,
      deploySize: 0,
      initSize: 0,
      previousDeploySize: itemA.deploySize,
      previousInitSize: itemA.initSize,
      solcSettings: DEFAULT_SOLC_SETTINGS,
      solcSettingsChanged: true,
    });
  });

  return mergedContractSizes;
};

export const countOversizedContracts = (contractSizes: ContractSize[]) => {
  return contractSizes.reduce((acc, el) => {
    if (el.deploySize > DEPLOYED_SIZE_LIMIT || el.initSize > INIT_SIZE_LIMIT) {
      acc++;
    }
    return acc;
  }, 0);
};

export const validateNoOversizedContracts = (contractSizes: ContractSize[]) => {
  const oversizedCount = countOversizedContracts(contractSizes);

  if (oversizedCount > 0) {
    throw new HardhatPluginError(
      pkg.name,
      'strict mode is enabled and oversized contracts were found',
    );
  }
};
